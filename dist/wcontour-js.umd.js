(function(Q,H){typeof exports=="object"&&typeof module!="undefined"?H(exports):typeof define=="function"&&define.amd?define(["exports"],H):(Q=typeof globalThis!="undefined"?globalThis:Q||self,H(Q.wContour={}))})(this,function(Q){"use strict";class H{constructor(){this.lineList=[]}getLineNum(){return this.lineList.length}}class q{constructor(s,e,a,i){this.xMin=s,this.xMax=e,this.yMin=a,this.yMax=i}include(s){return this.xMin<=s.xMin&&this.xMax>=s.xMax&&this.yMin<=s.yMin&&this.yMax>=s.yMax}}class se{constructor(){this.extent=new q,this.pointList=[],this.ijPointList=[]}}class O{constructor(s=0,e=0){this.x=s,this.y=e}clone(){return new O(this.x,this.y)}}class J{constructor(){this.point=new O}clone(){let s=new J;return s.id=this.id,s.borderIdx=this.borderIdx,s.bInnerIdx=this.bInnerIdx,s.point=this.point,s.value=this.value,s}}class oe{constructor(){this.sPoint=new O,this.point=new O}}class ee{constructor(s,e){this.i=s,this.j=e}}class Z{constructor(){this.pointList=[]}}function te(n,s){let e=Math.abs(n*1e-5);return Math.abs(n-s)<=e}function le(n,s,e){let a=(s.y-n.y)/(s.x-n.x),i=(a*a*n.x+a*(e.y-n.y)+e.x)/(a*a+1),t=a*(i-n.x)+n.y;return Math.sqrt((e.y-t)*(e.y-t)+(e.x-i)*(e.x-i))}function re(n){let s,e,a,i,t,l=n[0];for(s=l.x,a=l.x,e=l.y,i=l.y,t=1;t<n.length;t++)l=n[t],l.x<s&&(s=l.x),l.x>a&&(a=l.x),l.y<e&&(e=l.y),l.y>i&&(i=l.y);let o=new q;return o.xMin=s,o.yMin=e,o.xMax=a,o.yMax=i,o}function z(n,s){let e,a,i,t,l,o,p=n[0];for(a=p.x,t=p.x,i=p.y,l=p.y,o=1;o<n.length;o++)p=n[o],p.x<a&&(a=p.x),p.x>t&&(t=p.x),p.y<i&&(i=p.y),p.y>l&&(l=p.y);return s.xMin=a,s.yMin=i,s.xMax=t,s.yMax=l,e=(t-a)*(l-i),e}function K(n){let s,e,a=0,i=0;for(s=0;s<n.length-1;s++)e=n[s],s===0?(a=e.y,i=0):a<e.y&&(a=e.y,i=s);let t,l,o,p,f,h;return p=i-1,f=i,h=i+1,i===0&&(p=n.length-2),t=n[p],l=n[f],o=n[h],(o.x-t.x)*(l.y-t.y)-(l.x-t.x)*(o.y-t.y)>0}function F(n,s){let e=!1,a=n.length;if(a<3)return!1;let i=n[a-1].x,t=n[a-1].y,l,o,p,f;for(let h=0;h<a;h++){const g=n[h].x,x=n[h].y;g>i?(l=i,p=g,o=t,f=x):(l=g,p=i,o=x,f=t),g<s.x==s.x<=i&&(s.y-o)*(p-l)<(f-o)*(s.x-l)&&(e=!e),i=g,t=x}return e}function fe(n,s,e,a){let i,t,l=[],o,p,f;if(n.length===0){let u=e[0].value,r=e[0].value;for(let c of e)c.value>u&&(u=c.value),c.value<r&&(r=c.value);i=new R,p=a[0].value,p<r?(u=r,r=p,i.isHighCenter=!0):p>u&&(r=u,u=p,i.isHighCenter=!1),t=new Z,t.type="Border",t.value=p,l=[];for(let c of a)l.push(c.point);t.pointList=[],t.pointList.push(...l),t.pointList.length>0&&(i.isBorder=!0,i.lowValue=r,i.highValue=u,o=new q,i.area=z(t.pointList,o),i.isClockWise=K(t.pointList),i.extent=o,i.outLine=t,i.holeLines=[],n.push(i))}n.push(...s);let h,g,x=n.length,d;for(let u=1;u<x;u++)if(i=n[u],i.outLine.type==="Close"){h=i.extent,f=i.outLine.pointList[0];for(let r=u-1;r>=0;r--)if(d=n[r],g=d.extent,l=[],l.push(...d.outLine.pointList),F(l,f)&&h.xMin>g.xMin&&h.yMin>g.yMin&&h.xMax<g.xMax&&h.yMax<g.yMax){d.isHighCenter?i.isHighCenter=i.highValue!==d.lowValue:i.isHighCenter=i.lowValue===d.highValue;break}}return n}function ae(n,s){for(let e=0;e<s.length;e++){let a=s[e],i=re(a);for(let t=n.length-1;t>=0;t--){let l=n[t];if(l.extent.include(i)){let o=!0;for(let p of a)if(!F(l.outLine.pointList,p)){o=!1;break}if(o){l.addHole(a);break}}}}}function ue(n){let s=[],e,a;for(e=0;e<n.length;e++){let i=n[e];(!i.isBorder||i.isInnerBorder)&&(i.holeIndex=1,s.push(i))}if(s.length===0)return n;{let i=[];for(e=1;e<s.length;e++){let l=s[e];for(a=e-1;a>=0;a--){let o=s[a];if(o.extent.include(l.extent)&&F(o.outLine.pointList,l.outLine.pointList[0])){l.holeIndex=o.holeIndex+1,o.addHole(l);break}}}let t=[];for(e=0;e<s.length;e++)s[e].holeIndex===1&&t.push(s[e]);for(e=0;e<n.length;e++){let l=n[e];if(l.isBorder&&!l.isInnerBorder){for(a=0;a<t.length;a++){let o=t[a];l.extent.include(o.extent)&&F(l.outLine.pointList,o.outLine.pointList[0])&&l.addHole(o)}i.push(l)}}return i.push(...s),i}}class R{constructor(){this.isInnerBorder=!1,this.extent=new q,this.outLine=new Z,this.holeLines=[]}clone(){let s=new R;return s.isBorder=this.isBorder,s.lowValue=this.lowValue,s.highValue=this.highValue,s.isClockWise=this.isClockWise,s.startPointIdx=this.startPointIdx,s.isHighCenter=this.isHighCenter,s.extent=this.extent,s.area=this.area,s.outLine=this.outLine,s.holeLines=this.holeLines,s.holeIndex=this.holeIndex,s}hasHoles(){return this.holeLines.length>0}addHole(s){if(s instanceof R)this.holeLines.push(s.outLine);else{let e=s;K(e)&&(e=e.reverse());const a=new Z;a.pointList=e,this.holeLines.push(a)}}}function he(n,s,e,a,i,t){let l=!0,o,p,f,h;return s<e?n[e][i-1]===1&&n[e][i+1]===1?(o=n[e-1][i-1],p=n[e+1][i],f=n[e+1][i-1],o!==0&&p===0||o===0&&p!==0&&f!==0?(t[0]=e,t[1]=i-1):(t[0]=e,t[1]=i+1)):n[e][i-1]===1&&n[e+1][i]===1?(o=n[e+1][i-1],p=n[e+1][i+1],f=n[e][i-1],h=n[e][i+1],o===0||p===0||f===0||h===0?o===0&&h===0||p===0&&f===0?(t[0]=e,t[1]=i-1):(t[0]=e+1,t[1]=i):(t[0]=e,t[1]=i-1)):n[e][i+1]===1&&n[e+1][i]===1?(o=n[e+1][i-1],p=n[e+1][i+1],f=n[e][i-1],h=n[e][i+1],o===0||p===0||f===0||h===0?o===0&&h===0||p===0&&f===0?(t[0]=e,t[1]=i+1):(t[0]=e+1,t[1]=i):(t[0]=e,t[1]=i+1)):n[e][i-1]===1?(t[0]=e,t[1]=i-1):n[e][i+1]===1?(t[0]=e,t[1]=i+1):n[e+1][i]===1?(t[0]=e+1,t[1]=i):l=!1:a<i?n[e+1][i]===1&&n[e-1][i]===1?(o=n[e+1][i-1],p=n[e][i+1],f=n[e+1][i+1],o!==0&&p===0||o===0&&p!==0&&f!==0?(t[0]=e+1,t[1]=i):(t[0]=e-1,t[1]=i)):n[e+1][i]===1&&n[e][i+1]===1?(f=n[e-1][i],h=n[e+1][i],o=n[e-1][i+1],p=n[e+1][i+1],o===0||p===0||f===0||h===0?o===0&&h===0||p===0&&f===0?(t[0]=e+1,t[1]=i):(t[0]=e,t[1]=i+1):(t[0]=e+1,t[1]=i)):n[e-1][i]===1&&n[e][i+1]===1?(f=n[e-1][i],h=n[e+1][i],o=n[e-1][i+1],p=n[e+1][i+1],o===0||p===0||f===0||h===0?o===0&&h===0||p===0&&f===0?(t[0]=e-1,t[1]=i):(t[0]=e,t[1]=i+1):(t[0]=e-1,t[1]=i)):n[e+1][i]===1?(t[0]=e+1,t[1]=i):n[e-1][i]===1?(t[0]=e-1,t[1]=i):n[e][i+1]===1?(t[0]=e,t[1]=i+1):l=!1:s>e?n[e][i-1]===1&&n[e][i+1]===1?(o=n[e+1][i-1],p=n[e-1][i],f=n[e-1][i+1],o!==0&&p===0||o===0&&p!==0&&f!==0?(t[0]=e,t[1]=i-1):(t[0]=e,t[1]=i+1)):n[e][i-1]===1&&n[e-1][i]===1?(o=n[e-1][i-1],p=n[e-1][i+1],f=n[e][i-1],h=n[e][i+1],o===0||p===0||f===0||h===0?o===0&&h===0||p===0&&f===0?(t[0]=e,t[1]=i-1):(t[0]=e-1,t[1]=i):(t[0]=e,t[1]=i-1)):n[e][i+1]===1&&n[e-1][i]===1?(o=n[e-1][i-1],p=n[e-1][i+1],f=n[e][i-1],h=n[e][i+1],o===0||p===0||f===0||h===0?o===0&&h===0||p===0&&f===0?(t[0]=e,t[1]=i+1):(t[0]=e-1,t[1]=i):(t[0]=e,t[1]=i+1)):n[e][i-1]===1?(t[0]=e,t[1]=i-1):n[e][i+1]===1?(t[0]=e,t[1]=i+1):n[e-1][i]===1?(t[0]=e-1,t[1]=i):l=!1:a>i&&(n[e+1][i]===1&&n[e-1][i]===1?(o=n[e+1][i+1],p=n[e][i-1],f=n[e-1][i-1],o!==0&&p===0||o===0&&p!==0&&f!==0?(t[0]=e+1,t[1]=i):(t[0]=e-1,t[1]=i)):n[e+1][i]===1&&n[e][i-1]===1?(f=n[e-1][i],h=n[e+1][i],o=n[e-1][i-1],p=n[e+1][i-1],o===0||p===0||f===0||h===0?o===0&&h===0||p===0&&f===0?(t[0]=e+1,t[1]=i):(t[0]=e,t[1]=i-1):(t[0]=e+1,t[1]=i)):n[e-1][i]===1&&n[e][i-1]===1?(f=n[e-1][i],h=n[e+1][i],o=n[e-1][i-1],p=n[e+1][i-1],o===0||p===0||f===0||h===0?o===0&&h===0||p===0&&f===0?(t[0]=e-1,t[1]=i):(t[0]=e,t[1]=i-1):(t[0]=e-1,t[1]=i)):n[e+1][i]===1?(t[0]=e+1,t[1]=i):n[e-1][i]===1?(t[0]=e-1,t[1]=i):n[e][i-1]===1?(t[0]=e,t[1]=i-1):l=!1),l}function Y(n,s,e,a,i,t,l,o,p,f,h,g){let x=!0,d=0,u=0,r=0,c=0,L=!0;return n<s?e[s][t]!==-2&&e[s][t+1]!==-2?e[s][t]<e[s][t+1]?(d=l[t],u=o[s]+e[s][t]*(o[s+1]-o[s]),r=s,c=t,e[r][c]=-2,L=!1):(d=l[t+1],u=o[s]+e[s][t+1]*(o[s+1]-o[s]),r=s,c=t+1,e[r][c]=-2,L=!1):e[s][t]!==-2&&e[s][t+1]===-2?(d=l[t],u=o[s]+e[s][t]*(o[s+1]-o[s]),r=s,c=t,e[r][c]=-2,L=!1):e[s][t]===-2&&e[s][t+1]!==-2?(d=l[t+1],u=o[s]+e[s][t+1]*(o[s+1]-o[s]),r=s,c=t+1,e[r][c]=-2,L=!1):a[s+1][t]!==-2?(d=l[t]+a[s+1][t]*(l[t+1]-l[t]),u=o[s+1],r=s+1,c=t,a[r][c]=-2,L=!0):x=!1:i<t?a[s][t]!==-2&&a[s+1][t]!==-2?a[s][t]<a[s+1][t]?(d=l[t]+a[s][t]*(l[t+1]-l[t]),u=o[s],r=s,c=t,a[r][c]=-2,L=!0):(d=l[t]+a[s+1][t]*(l[t+1]-l[t]),u=o[s+1],r=s+1,c=t,a[r][c]=-2,L=!0):a[s][t]!==-2&&a[s+1][t]===-2?(d=l[t]+a[s][t]*(l[t+1]-l[t]),u=o[s],r=s,c=t,a[r][c]=-2,L=!0):a[s][t]===-2&&a[s+1][t]!==-2?(d=l[t]+a[s+1][t]*(l[t+1]-l[t]),u=o[s+1],r=s+1,c=t,a[r][c]=-2,L=!0):e[s][t+1]!==-2?(d=l[t+1],u=o[s]+e[s][t+1]*(o[s+1]-o[s]),r=s,c=t+1,e[r][c]=-2,L=!1):x=!1:l[t]<p?e[s-1][t]!==-2&&e[s-1][t+1]!==-2?e[s-1][t]>e[s-1][t+1]?(d=l[t],u=o[s-1]+e[s-1][t]*(o[s]-o[s-1]),r=s-1,c=t,e[r][c]=-2,L=!1):(d=l[t+1],u=o[s-1]+e[s-1][t+1]*(o[s]-o[s-1]),r=s-1,c=t+1,e[r][c]=-2,L=!1):e[s-1][t]!==-2&&e[s-1][t+1]===-2?(d=l[t],u=o[s-1]+e[s-1][t]*(o[s]-o[s-1]),r=s-1,c=t,e[r][c]=-2,L=!1):e[s-1][t]===-2&&e[s-1][t+1]!==-2?(d=l[t+1],u=o[s-1]+e[s-1][t+1]*(o[s]-o[s-1]),r=s-1,c=t+1,e[r][c]=-2,L=!1):a[s-1][t]!==-2?(d=l[t]+a[s-1][t]*(l[t+1]-l[t]),u=o[s-1],r=s-1,c=t,a[r][c]=-2,L=!0):x=!1:a[s+1][t-1]!==-2&&a[s][t-1]!==-2?a[s+1][t-1]>a[s][t-1]?(d=l[t-1]+a[s+1][t-1]*(l[t]-l[t-1]),u=o[s+1],r=s+1,c=t-1,a[r][c]=-2,L=!0):(d=l[t-1]+a[s][t-1]*(l[t]-l[t-1]),u=o[s],r=s,c=t-1,a[r][c]=-2,L=!0):a[s+1][t-1]!==-2&&a[s][t-1]===-2?(d=l[t-1]+a[s+1][t-1]*(l[t]-l[t-1]),u=o[s+1],r=s+1,c=t-1,a[r][c]=-2,L=!0):a[s+1][t-1]===-2&&a[s][t-1]!==-2?(d=l[t-1]+a[s][t-1]*(l[t]-l[t-1]),u=o[s],r=s,c=t-1,a[r][c]=-2,L=!0):e[s][t-1]!==-2?(d=l[t-1],u=o[s]+e[s][t-1]*(o[s+1]-o[s]),r=s,c=t-1,e[r][c]=-2,L=!1):x=!1,f[0]=r,f[1]=c,h[0]=d,h[1]=u,g[0]=L,x}function xe(n,s,e,a,i){let t=[],l,o,p,f,h,g,x;l=[],l.push(...n);let d,u,r,c,L=[];for(L.length=s.length-1,g=0;g<L.length;g++)L[g]=0;let y,b,w,v=0,M=0,P=0,I=[],C,B,k;for(b=s.length,g=0;g<b;g++){if(s[g].id===-1)continue;y=g,I.push(s[g]);let $=!1;if(L[y]<2){r=s[y],k=r.bInnerIdx,d=[];let G=[];d.push(r.point),G.push(y),C=r.borderIdx,B=C,y+=1,k+=1,k===i[C]-1&&(y=y-(i[C]-1)),w=0;do{if(r=s[y],r.id===-1){if(L[y]===1)break;P=r.value,d.push(r.point),L[y]+=1,G.push(y)}else{if(L[y]===2)break;for(L[y]+=1,G.push(y),o=l[r.id],w===0?(v=o.value,M=o.value,w+=1):v===M&&(o.value>v?M=o.value:o.value<v&&(v=o.value),w+=1),u=[],u.push(...o.pointList),p=u[0],r.point.x===p.x&&r.point.y===p.y||u.reverse(),d.push(...u),x=0;x<s.length;x++)if(x!==y&&(c=s[x],c.id===r.id)){y=x,k=c.bInnerIdx,L[y]+=1,G.push(y),B=c.borderIdx,r.borderIdx>0&&r.borderIdx===c.borderIdx&&($=!0);break}}if(y===g){if(d.length>0){if($){let U=!1,D=0;for(let N=0;N<r.borderIdx;N++)D+=i[N];let S=D,j=D+i[r.borderIdx],X=S;for(let N=S;N<j;N++)if(G.indexOf(N)<0){X=N;break}if(F(d,s[X].point)&&(U=!0),U)break}f=new R,f.isBorder=!0,f.isInnerBorder=$,f.lowValue=v,f.highValue=M,h=new q,f.area=z(d,h),f.isClockWise=!0,f.startPointIdx=I.length-1,f.extent=h,f.outLine.pointList=d,f.outLine.value=v,f.isHighCenter=!0,v===M&&P<v&&(f.isHighCenter=!1),f.outLine.type="Border",f.holeLines=[],t.push(f)}break}y+=1,k+=1,C!==B&&(C=B),k===i[C]-1&&(y=y-(i[C]-1),k=0)}while(!0)}if($=!1,y=g,L[y]<2){d=[];let G=[];r=s[y],k=r.bInnerIdx,d.push(r.point),G.push(y),C=r.borderIdx,B=C,y+=-1,k+=-1,k===-1&&(y=y+(i[C]-1)),w=0;do{if(r=s[y],r.id===-1){if(L[y]===1)break;P=r.value,d.push(r.point),G.push(y),L[y]+=1}else{if(L[y]===2)break;for(L[y]+=1,G.push(y),o=l[r.id],w===0?(v=o.value,M=o.value,w+=1):v===M&&(o.value>v?M=o.value:o.value<v&&(v=o.value),w+=1),u=[],u.push(...o.pointList),p=u[0],r.point.x===p.x&&r.point.y===p.y||u.reverse(),d.push(...u),x=0;x<s.length;x++)if(x!==y&&(c=s[x],c.id===r.id)){y=x,k=c.bInnerIdx,L[y]+=1,G.push(y),B=c.borderIdx,r.borderIdx>0&&r.borderIdx===c.borderIdx&&($=!0);break}}if(y===g){if(d.length>0){if($){let U=!1,D=0;for(let N=0;N<r.borderIdx;N++)D+=i[N];let S=D,j=D+i[r.borderIdx],X=S;for(let N=S;N<j;N++)if(G.indexOf(N)<0){X=N;break}if(F(d,s[X].point)&&(U=!0),U)break}f=new R,f.isBorder=!0,f.isInnerBorder=$,f.lowValue=v,f.highValue=M,h=new q,f.area=z(d,h),f.isClockWise=!1,f.startPointIdx=I.length-1,f.extent=h,f.outLine.pointList=d,f.outLine.value=v,f.isHighCenter=!0,v===M&&P<v&&(f.isHighCenter=!1),f.outLine.type="Border",f.holeLines=[],t.push(f)}break}y+=-1,k+=-1,C!==B&&(C=B),k===-1&&(y=y+i[C],k=i[C]-1)}while(!0)}}let E=[],W;for(g=0;g<l.length;g++)if(o=l[g],o.type==="Close"){for(f=new R,f.isBorder=!1,f.lowValue=o.value,f.highValue=o.value,h=new q,f.area=z(o.pointList,h),f.isClockWise=K(o.pointList),f.extent=h,f.outLine=o,f.isHighCenter=!0,f.holeLines=[],W=!1,x=0;x<E.length;x++)if(f.area>E[x].area){E.splice(x,0,f),W=!0;break}W||E.push(f)}t.length===0&&(o=new Z,o.type="Border",o.value=a[0],o.pointList=[],o.pointList.push(...e.lineList[0].pointList),o.pointList.length>0&&(f=new R,f.lowValue=o.value,f.highValue=o.value,h=new q,f.area=z(o.pointList,h),f.isClockWise=K(o.pointList),f.extent=h,f.outLine=o,f.isHighCenter=!1,t.push(f))),t.push(...E);let _,m,V=t.length,T;for(g=V-1;g>=0;g+=-1)if(f=t[g],f.outLine.type==="Close"){for(_=f.extent,v=f.lowValue,p=f.outLine.pointList[0],x=g-1;x>=0;x+=-1)if(T=t[x],m=T.extent,M=T.lowValue,u=[],u.push(...T.outLine.pointList),F(u,p)&&_.xMin>m.xMin&&_.yMin>m.yMin&&_.xMax<m.xMax&&_.yMax<m.yMax){(v<M||v===M&&T.isHighCenter)&&(f.isHighCenter=!1);break}}return t}function ne(n,s,e,a,i,t,l){let o,p,f,h,g,x,d,u,r=a.length,c=i.length,L=a[1]-a[0],y=i[1]-i[0],b=t[0],w=t[1];if(o=s[b][w],p=s[b][w+1],f=s[b+1][w],h=s[b+1][w+1],g=o+(f-o)*((n.y-i[b])/y),x=p+(h-p)*((n.y-i[b])/y),d=g+(x-g)*((n.x-a[w])/L),o=e[b][w],p=e[b][w+1],f=e[b+1][w],h=e[b+1][w+1],g=o+(f-o)*((n.y-i[b])/y),x=p+(h-p)*((n.y-i[b])/y),u=g+(x-g)*((n.x-a[w])/L),l?(n.x+=d,n.y+=u):(n.x-=d,n.y-=u),!(n.x>=a[w]&&n.x<=a[w+1]&&n.y>=i[b]&&n.y<=i[b+1])){if(n.x<a[0]||n.x>a[a.length-1]||n.y<i[0]||n.y>i[i.length-1])return!1;for(let v=b-2;v<b+3;v++)if(v>=0&&v<c&&n.y>=i[v]&&n.y<=i[v+1]){b=v;for(let M=w-2;M<w+3;M++)if(M>=0&&M<r&&n.x>=a[M]&&n.x<=a[M+1]){w=M;break}break}}return t[0]=b,t[1]=w,!0}const A=class{constructor(n,s,e,a){this._borders=[],this._s0=n,this._m=n.length,this._n=n[0].length,this._xs=s,this._ys=e,this._undefData=a,this._s1=this._tracingDataFlag(),this._borders=this._tracingBorders()}_tracingDataFlag(){let n=[];const{_s0:s,_m:e,_n:a,_undefData:i}=this;for(let l=0;l<e;l++){n[l]=[];for(let o=0;o<a;o++)n[l][o]=te(s[l][o],i)?0:1}for(let l=1;l<e-1;l++)for(let o=1;o<a-1;o++)if(n[l][o]===1){let p=n[l][o-1],f=n[l][o+1],h=n[l-1][o],g=n[l+1][o],x=n[l-1][o-1],d=n[l-1][o+1],u=n[l+1][o-1],r=n[l+1][o+1];p>0&&f>0&&h>0&&g>0&&x>0&&d>0&&u>0&&r>0&&(n[l][o]=2),p+f+h+g+x+d+u+r<=2&&(n[l][o]=0)}let t;for(;;){t=!1;for(let l=1;l<e-1;l++)for(let o=1;o<a-1;o++)if(n[l][o]===1){let p=n[l][o-1],f=n[l][o+1],h=n[l-1][o],g=n[l+1][o],x=n[l-1][o-1],d=n[l-1][o+1],u=n[l+1][o-1],r=n[l+1][o+1];(p===0&&f===0||h===0&&g===0)&&(n[l][o]=0,t=!0),(u===0&&f===0&&h===0||r===0&&p===0&&h===0||x===0&&f===0&&g===0||d===0&&p===0&&g===0)&&(n[l][o]=0,t=!0)}if(!t)break}for(let l=0;l<a;l++)n[0][l]===1&&(n[1][l]===0?n[0][l]=0:l===0?n[0][l+1]===0&&(n[0][l]=0):l===a-1?n[0][a-2]===0&&(n[0][l]=0):n[0][l-1]===0&&n[0][l+1]===0&&(n[0][l]=0)),n[e-1][l]===1&&(n[e-2][l]===0?n[e-1][l]=0:l===0?n[e-1][l+1]===0&&(n[e-1][l]=0):l===a-1?n[e-1][a-2]===0&&(n[e-1][l]=0):n[e-1][l-1]===0&&n[e-1][l+1]===0&&(n[e-1][l]=0));for(let l=0;l<e;l++)n[l][0]===1&&(n[l][1]===0?n[l][0]=0:l===0?n[l+1][0]===0&&(n[l][0]=0):l===e-1?n[e-2][0]===0&&(n[l][0]=0):n[l-1][0]===0&&n[l+1][0]===0&&(n[l][0]=0)),n[l][a-1]===1&&(n[l][a-2]===0?n[l][a-1]=0:l===0?n[l+1][a-1]===0&&(n[l][a-1]=0):l===e-1?n[e-2][a-1]===0&&(n[l][a-1]=0):n[l-1][a-1]===0&&n[l+1][a-1]===0&&(n[l][a-1]=0));return n}_tracingBorders(){const{_s1:n,_m:s,_n:e,_xs:a,_ys:i}=this;let t=[],l=[];for(let h=0;h<s+2;h++){l[h]=[];for(let g=0;g<e+2;g++)h===0||h===s+1||g===0||g===e+1?l[h][g]=0:l[h][g]=n[h-1][g-1]}let o=[];for(let h=0;h<s+2;h++){o[h]=[];for(let g=0;g<e+2;g++)if(l[h][g]===1){let x=l[h][g-1],d=l[h][g+1],u=l[h-1][g],r=l[h+1][g],c=l[h-1][g-1],L=l[h-1][g+1],y=l[h+1][g-1],b=l[h+1][g+1];x===1&&d===1&&u===1&&r===1&&(c===0&&b===0||L===0&&y===0)?o[h][g]=2:o[h][g]=1}else o[h][g]=0}for(let h=1;h<s+1;h++)for(let g=1;g<e+1;g++)if(l[h][g]===1){let x=[],d=[];x.push(new O(a[g-1],i[h-1])),d.push(new ee(h-1,g-1));let u=0,r=0,c=h,L=g,y=c,b=-1;for(;;){let w=[];if(w[0]=u,w[1]=r,he(l,y,c,b,L,w))u=w[0],r=w[1],y=c,b=L,c=u,L=r,o[u][r]=o[u][r]-1,o[u][r]===0&&(l[u][r]=3);else break;if(x.push(new O(a[r-1],i[u-1])),d.push(new ee(u-1,r-1)),u===h&&r===g)break}if(o[h][g]=o[h][g]-1,o[h][g]===0&&(l[h][g]=3),x.length>1){let w=new se;w.area=z(x,w.extent),w.isOutLine=!0,w.isClockwise=!0,w.pointList=x,w.ijPointList=d,t.push(w)}}let p=[];for(let h=1;h<t.length;h++){const g=t[h];for(let x=0;x<h;x++){const d=t[h];if(g.area>d.area){t.splice(h,1),t.splice(x,0,g);break}}}let f;if(t.length===1){const h=t[0];K(h.pointList)||(h.pointList=h.pointList.reverse(),h.ijPointList.reverse()),h.isClockwise=!0,f=[],f.push(h);let g=new H;g.lineList=f,p.push(g)}else for(let h=0;h<t.length&&h!==t.length;h++){const g=t[h];K(g.pointList)||(g.pointList.reverse(),g.ijPointList.reverse()),g.isClockwise=!0,f=[],f.push(g);for(let d=h+1;d<t.length&&d!==t.length;d++){const u=t[h];if(u.extent.xMin>g.extent.xMin&&u.extent.xMax<g.extent.xMax&&u.extent.yMin>g.extent.yMin&&u.extent.yMax<g.extent.yMax){const r=u.pointList[0];F(g.pointList,r)&&(u.isOutLine=!1,K(u.pointList)&&(u.pointList.reverse(),u.ijPointList.reverse()),u.isClockwise=!1,f.push(u),t.splice(d,1),d=d-1)}}let x=new H;x.lineList=f,p.push(x)}return p}tracingContourLines(n){const{_s0:s,_s1:e,_xs:a,_ys:i,_m:t,_n:l,_borders:o,_undefData:p}=this;let f=[],h,g=n[0]*1e-5;g===0&&(g=1e-5);for(let P=0;P<t;P++)for(let I=0;I<l;I++)te(s[P][I],p)||(s[P][I]=s[P][I]+g);let x=[],d=[];x[0]=[],x[1]=[],d[0]=[],d[1]=[];for(let P=0;P<t;P++){x[0][P]=[],x[1][P]=[],d[0][P]=[],d[1][P]=[];for(let I=0;I<l;I++)I<l-1&&(x[0][P][I]=-1,x[1][P][I]=-1),P<t-1&&(d[0][P][I]=-1,d[1][P][I]=-1)}let u,r,c,L,y;for(let P=0;P<o.length;P++){const I=o[P];for(let C=0;C<I.getLineNum();C++){const k=I.lineList[C].ijPointList;for(u=0;u<k.length-1;u++)L=k[u],y=k[u+1],L.i===y.i?(r=L.i,c=Math.min(L.j,y.j),x[0][r][c]=P,y.j>L.j?x[1][r][c]=1:x[1][r][c]=0):(c=L.j,r=Math.min(L.i,y.i),d[0][r][c]=P,y.i>L.i?d[1][r][c]=0:d[1][r][c]=1)}}let b=[],w=[],v,M;for(M=0;M<n.length;M++){v=n[M];for(let P=0;P<t;P++){b[P]=[],w[P]=[];for(let I=0;I<l;I++)I<l-1&&(e[P][I]!==0&&e[P][I+1]!==0&&(s[P][I]-v)*(s[P][I+1]-v)<0?b[P][I]=(v-s[P][I])/(s[P][I+1]-s[P][I]):b[P][I]=-2),P<t-1&&(e[P][I]!==0&&e[P+1][I]!==0&&(s[P][I]-v)*(s[P+1][I]-v)<0?w[P][I]=(v-s[P][I])/(s[P+1][I]-s[P][I]):w[P][I]=-2)}h=A.isoline_UndefData(s,a,i,v,b,w,x,d,f.length);for(let P of h)f.push(P)}for(let P=0;P<o.length;P++){const C=o[P].lineList[0];for(let B=0;B<f.length;B++){const k=f[B];if(k.type==="Close"){const E=k.pointList[0];F(C.pointList,E)&&(k.borderIdx=P)}f.splice(B,1),f.splice(B,0,k)}}return f}tracingPolygons(n,s){const e=this._s0,a=this._borders;let i=[],t=[],l,o=[],p,f,h,g,x,d,u,r=[],c=[],L,y,b,w=0,v;for(d=0;d<a.length;d++){if(c=[],o=[],r=[],i=[],f=a[d],h=f.lineList[0],p=h.pointList,K(p)||p.reverse(),f.getLineNum()===1){for(u=0;u<p.length;u++)g=p[u],x=new J,x.id=-1,x.point=g,x.value=e[h.ijPointList[u].i][h.ijPointList[u].j],c.push(x);for(u=0;u<n.length;u++)L=n[u],L.borderIdx===d&&(r.push(L),L.type==="Border"&&(g=L.pointList[0],x=new J,x.id=r.length-1,x.point=g,x.value=L.value,o.push(x),g=L.pointList[L.pointList.length-1],x=new J,x.id=r.length-1,x.point=g,x.value=L.value,o.push(x)));if(r.length===0){if(b=h.ijPointList[0],y=new R,e[b.i][b.j]<s[0])w=s[0],y.isHighCenter=!1;else{for(u=s.length-1;u>=0;u--)if(e[b.i][b.j]>s[u]){w=s[u];break}y.isHighCenter=!0}p.length>0&&(y.isBorder=!0,y.highValue=w,y.lowValue=w,y.extent=new q,y.area=z(p,y.extent),y.startPointIdx=0,y.isClockWise=!0,y.outLine.type="Border",y.outLine.value=w,y.outLine.borderIdx=d,y.outLine.pointList=p,y.holeLines=[],i.push(y))}else o.length>0?l=A.insertPoint2Border(o,c):l=c,i=A.tracingPolygons_Line_Border(r,l);i=A.addPolygonHoles(i)}else{for(h=f.lineList[0],u=0;u<n.length;u++)L=n[u],L.borderIdx===d&&(r.push(L),L.type==="Border"&&(g=L.pointList[0],x=new J,x.id=r.length-1,x.point=g,x.value=L.value,o.push(x),g=L.pointList[L.pointList.length-1],x=new J,x.id=r.length-1,x.point=g,x.value=L.value,o.push(x)));if(r.length===0){if(b=h.ijPointList[0],y=new R,e[b.i][b.j]<s[0])w=s[0],y.isHighCenter=!1;else{for(u=s.length-1;u>=0;u--)if(e[b.i][b.j]>s[u]){w=s[u];break}y.isHighCenter=!0}p.length>0&&(y.isBorder=!0,y.highValue=w,y.lowValue=w,y.area=z(p,y.extent),y.startPointIdx=0,y.isClockWise=!0,y.outLine.type="Border",y.outLine.value=w,y.outLine.borderIdx=d,y.outLine.pointList=p,y.holeLines=[],i.push(y))}else{v=[],v.length=f.getLineNum(),l=A.insertPoint2Border_Ring(e,o,f,v),i=xe(r,l,f,s,v);let P=[];for(;i.length>0;){let I=!1;for(u=0;u<P.length;u++)if(i[0].area>P[u].area){P.push(i[0]),I=!0;break}I||P.push(i[0]),i.splice(0,1)}i=P}let M=[];for(u=0;u<f.getLineNum();u++)M.push(f.lineList[u].pointList);M.length>0&&ae(i,M),i=ue(i)}t.push(...i)}for(let M of t)K(M.outLine.pointList)||M.outLine.pointList.reverse();return t}static isoline_UndefData(n,s,e,a,i,t,l,o,p){let f=[],h,g,x,d;h=n.length,g=n[0].length;let u,r,c,L,y=0,b=0,w,v,M=0,P=0,I,C,B,k,E,W=!0,_=new oe;for(x=0;x<h;x++)for(d=0;d<g;d++){if(d<g-1&&l[0][x][d]>-1&&i[x][d]!==-2){for(E=[],r=x,L=d,w=s[L]+i[r][L]*(s[L+1]-s[L]),v=e[r],l[1][x][d]===0?(u=-1,_.sPoint.x=s[d+1],_.sPoint.y=e[x]):(u=r,_.sPoint.x=s[d],_.sPoint.y=e[x]),c=L,B=new O,B.x=w,B.y=v,E.push(B),_.index=p+f.length,_.point=B,_.borderIdx=l[0][x][d],A._endPointList.push(_),k=new Z,k.type="Border",k.borderIdx=l[0][x][d];;){let m=[y,b],V=[M,P],T=[W];if(Y(u,r,t,i,c,L,s,e,w,m,V,T)){if(y=m[0],b=m[1],M=V[0],P=V[1],W=T[0],B=new O,B.x=M,B.y=P,E.push(B),W){if(l[0][y][b]>-1){l[1][y][b]===0?(_.sPoint.x=s[b+1],_.sPoint.y=e[y]):(_.sPoint.x=s[b],_.sPoint.y=e[y]);break}}else if(o[0][y][b]>-1){o[1][y][b]===0?(_.sPoint.x=s[b],_.sPoint.y=e[y]):(_.sPoint.x=s[b],_.sPoint.y=e[y+1]);break}w=M,u=r,c=L,r=y,L=b}else{k.type="Error";break}}i[x][d]=-2,E.length>1&&k.type!=="Error"?(_.point=B,A._endPointList.push(_),k.value=a,k.pointList=E,f.push(k)):A._endPointList.pop()}if(x<h-1&&o[0][x][d]>-1&&t[x][d]!==-2){for(E=[],r=x,L=d,w=s[L],v=e[r]+t[r][L]*(e[r+1]-e[r]),u=r,o[1][x][d]===0?(c=-1,_.sPoint.x=s[d],_.sPoint.y=e[x]):(c=L,_.sPoint.x=s[d],_.sPoint.y=e[x+1]),B=new O,B.x=w,B.y=v,E.push(B),_.index=p+f.length,_.point=B,_.borderIdx=o[0][x][d],A._endPointList.push(_),k=new Z,k.type="Border",k.borderIdx=o[0][x][d];;){let m=[y,b],V=[M,P],T=[W];if(Y(u,r,t,i,c,L,s,e,w,m,V,T)){if(y=m[0],b=m[1],M=V[0],P=V[1],W=T[0],B=new O,B.x=M,B.y=P,E.push(B),W){if(l[0][y][b]>-1){l[1][y][b]===0?(_.sPoint.x=s[b+1],_.sPoint.y=e[y]):(_.sPoint.x=s[b],_.sPoint.y=e[y]);break}}else if(o[0][y][b]>-1){o[1][y][b]===0?(_.sPoint.x=s[b],_.sPoint.y=e[y]):(_.sPoint.x=s[b],_.sPoint.y=e[y+1]);break}w=M,u=r,c=L,r=y,L=b}else{k.type="Error";break}}t[x][d]=-2,E.length>1&&k.type!=="Error"?(_.point=B,A._endPointList.push(_),k.value=a,k.pointList=E,f.push(k)):A._endPointList.pop()}}for(d=0;d<g-1;d++)i[0][d]!==-2&&(i[0][d]=-2),i[h-1][d]!==-2&&(i[h-1][d]=-2);for(x=0;x<h-1;x++)t[x][0]!==-2&&(t[x][0]=-2),t[x][g-1]!==-2&&(t[x][g-1]=-2);for(x=1;x<h-2;x++)for(d=1;d<g-1;d++)if(t[x][d]!==-2){let m=[];for(r=x,L=d,w=s[L],v=e[x]+t[x][L]*(e[x+1]-e[x]),c=-1,u=r,I=w,C=v,B=new O,B.x=w,B.y=v,m.push(B),k=new Z,k.type="Close";;){let V=[],T=[];if(Y(u,r,t,i,c,L,s,e,w,V,T,[])){if(y=V[0],b=V[1],M=T[0],P=T[1],B=new O,B.x=M,B.y=P,m.push(B),Math.abs(P-C)<1e-6&&Math.abs(M-I)<1e-6)break;w=M,u=r,c=L,r=y,L=b}else{k.type="Error";break}}t[x][d]=-2,m.length>1&&k.type!=="Error"&&(k.value=a,k.pointList=m,f.push(k))}for(x=1;x<h-1;x++)for(d=1;d<g-2;d++)if(i[x][d]!==-2){let m=[];for(r=x,L=d,w=s[L]+i[x][d]*(s[L+1]-s[L]),v=e[x],c=L,u=-1,I=w,C=v,B=new O,B.x=w,B.y=v,m.push(B),k=new Z,k.type="Close";;){let V=[],T=[];if(Y(u,r,t,i,c,L,s,e,w,V,T,[])){if(y=V[0],b=V[1],M=T[0],P=T[1],B=new O,B.x=M,B.y=P,m.push(B),Math.abs(P-C)<1e-6&&Math.abs(M-I)<1e-6)break;w=M,u=r,c=L,r=y,L=b}else{k.type="Error";break}}i[x][d]=-2,m.length>1&&k.type!=="Error"&&(k.value=a,k.pointList=m,f.push(k))}return f}static tracingPolygons_Line_Border(n,s){if(n.length===0)return[];let e=[],a=[],i,t,l,o,p,f;a.push(...n);let h,g,x,d=[];for(d.length=s.length-1,p=0;p<d.length;p++)d[p]=0;let u,r,c,L,y=0,b=0,w=0,v=[];for(r=s.length-1,p=0;p<r;p++)if(s[p].id!==-1){if(u=p,h=[],v.push(s[p]),d[u]<2)for(h.push(s[u].point),u+=1,u===r&&(u=0),c=0,L=0;;){if(x=s[u],x.id===-1){if(d[u]===1)break;w=x.value,L+=1,h.push(x.point),d[u]+=1}else{if(d[u]===2)break;for(d[u]+=1,i=a[x.id],c===0?(y=i.value,b=i.value,c+=1):(i.value>y?b=i.value:i.value<y&&(y=i.value),c+=1),g=[],g.push(...i.pointList),t=g[0],x.point.x===t.x&&x.point.y===t.y||g.reverse(),h.push(...g),f=0;f<s.length-1;f++)if(f!==u&&s[f].id===x.id){u=f,d[u]+=1;break}}if(u===p){h.length>0&&(l=new R,l.isBorder=!0,l.lowValue=y,l.highValue=b,o=new q,l.area=z(h,o),l.isClockWise=!0,l.startPointIdx=v.length-1,l.extent=o,l.outLine.pointList=h,l.outLine.value=y,l.isHighCenter=!0,l.holeLines=[],L>0&&w<y&&(l.isHighCenter=!1,l.highValue=y),l.outLine.type="Border",e.push(l));break}u+=1,u===r&&(u=0)}if(u=p,d[u]<2)for(h=[],h.push(s[u].point),u+=-1,u===-1&&(u=r-1),c=0,L=0;;){if(x=s[u],x.id===-1){if(d[u]===1)break;w=x.value,L+=1,h.push(x.point),d[u]+=1}else{if(d[u]===2)break;for(d[u]+=1,i=a[x.id],c===0?(y=i.value,b=i.value,c+=1):(i.value>y?b=i.value:i.value<y&&(y=i.value),c+=1),g=[],g.push(...i.pointList),t=g[0],x.point.x===t.x&&x.point.y===t.y||g.reverse(),h.push(...g),f=0;f<s.length-1;f++)if(f!==u&&s[f].id===x.id){u=f,d[u]+=1;break}}if(u===p){h.length>0&&(l=new R,l.isBorder=!0,l.lowValue=y,l.highValue=b,o=new q,l.area=z(h,o),l.isClockWise=!1,l.startPointIdx=v.length-1,l.extent=o,l.outLine.pointList=h,l.outLine.value=y,l.isHighCenter=!0,l.holeLines=[],L>0&&w<y&&(l.isHighCenter=!1,l.highValue=y),l.outLine.type="Border",e.push(l));break}u+=-1,u===-1&&(u=r-1)}}let M=[],P;for(p=0;p<a.length;p++)if(i=a[p],i.type==="Close"&&i.pointList.length>0){for(l=new R,l.isBorder=!1,l.lowValue=i.value,l.highValue=i.value,o=new q,l.area=z(i.pointList,o),l.isClockWise=K(i.pointList),l.extent=o,l.outLine=i,l.isHighCenter=!0,l.holeLines=[],P=!1,f=0;f<M.length;f++)if(l.area>M[f].area){M.splice(f,0,l),P=!0;break}P||M.push(l)}return e=fe(e,M,a,s),e}static addPolygonHoles(n){let s=[],e,a;for(e=0;e<n.length;e++){let i=n[e];i.isBorder||(i.holeIndex=1,s.push(i))}if(s.length===0)return n;{let i=[];for(e=1;e<s.length;e++){let l=s[e];for(a=e-1;a>=0;a--){let o=s[a];if(o.extent.include(l.extent)&&F(o.outLine.pointList,l.outLine.pointList[0])){l.holeIndex=o.holeIndex+1,o.addHole(l);break}}}let t=[];for(e=0;e<s.length;e++)s[e].holeIndex===1&&t.push(s[e]);for(e=0;e<n.length;e++){let l=n[e];if(l.isBorder===!0){for(a=0;a<t.length;a++){let o=t[a];l.extent.include(o.extent)&&F(l.outLine.pointList,o.outLine.pointList[0])&&l.addHole(o)}i.push(l)}}return i.push(...s),i}}tracingStreamline(n,s,e,a,i,t){let l=[],o=n[1].length,p=n.length,f=[],h=[],g=e[1]-e[0],x=a[1]-a[0];t===0&&(t=1);let d=g/Math.pow(t,2),u=d*1.5,r,c;for(r=0;r<p;r++)for(f[r]=[],h[r]=[],c=0;c<o;c++)if(Math.abs(n[r][c]/i-1)<.01)f[r][c]=.1,h[r][c]=.1;else{let M=Math.sqrt(n[r][c]*n[r][c]+s[r][c]*s[r][c]);M===0&&(M=1),f[r][c]=n[r][c]/M*g/t,h[r][c]=s[r][c]/M*x/t}let L=[],y=[];for(r=0;r<p-1;r++)for(L[r]=[],y[r]=[],c=0;c<o-1;c++)r%2===0&&c%2===0?y[r][c]=0:y[r][c]=1,L[r][c]=[];let b,w,v=0;for(r=0;r<p-1;r++)for(c=0;c<o-1;c++)if(y[r][c]===0){let M=[],P=new O,I,C,B,k=new Z;P.x=e[c]+g/2,P.y=a[r]+x/2,M.push(P.clone()),w=new J,w.point=P.clone(),w.id=v,L[r][c].push(w),y[r][c]=1,I=r,C=c;let E=500;for(B=0;B<E;){let W=[];W[0]=I,W[1]=C;let _=ne(P,f,h,e,a,W,!0);if(I=W[0],C=W[1],_){if(Math.abs(n[I][C]/i-1)<.01||Math.abs(n[I][C+1]/i-1)<.01||Math.abs(n[I+1][C]/i-1)<.01||Math.abs(n[I+1][C+1]/i-1)<.01)break;{let m=!1;for(let V of L[I][C])if(Math.sqrt((P.x-V.point.x)*(P.x-V.point.x)+(P.y-V.point.y)*(P.y-V.point.y))<d){m=!0;break}if(!m&&L[I][C].length>1){let V=L[I][C][0],T=L[I][C][1];v===V.id&&v===T.id||(b=le(V.point,T.point,P),b<u&&(m=!0))}if(!m)M.push(P.clone()),w=new J,w.point=P.clone(),w.id=v,L[I][C].push(w),y[I][C]=1;else break}}else break;B+=1}for(P.x=e[c]+g/2,P.y=a[r]+x/2,I=r,C=c,B=0;B<E;){let W=[];W[0]=I,W[1]=C;let _=ne(P,f,h,e,a,W,!1);if(I=W[0],C=W[1],_){if(Math.abs(n[I][C]/i-1)<.01||Math.abs(n[I][C+1]/i-1)<.01||Math.abs(n[I+1][C]/i-1)<.01||Math.abs(n[I+1][C+1]/i-1)<.01)break;{let m=!1;for(let V of L[I][C])if(Math.sqrt((P.x-V.point.x)*(P.x-V.point.x)+(P.y-V.point.y)*(P.y-V.point.y))<d){m=!0;break}if(!m&&L[I][C].length>1){let V=L[I][C][0],T=L[I][C][1];v===V.id&&v===T.id||(b=le(V.point,T.point,P),b<u&&(m=!0))}if(!m)M.splice(0,0,P.clone()),w=new J,w.point=P.clone(),w.id=v,L[I][C].push(w),y[I][C]=1;else break}}else break;B+=1}M.length>1&&(k.pointList=M,l.push(k),v+=1)}return l}static insertPoint2Border(n,s){let e,a,i,t,l,o,p,f=[];for(f.push(...s),i=0;i<n.length;i++)for(a=n[i],p=a.point,e=f[0],l=e.point,t=1;t<f.length;t++){if(e=f[t],o=e.point,(p.x-l.x)*(p.x-o.x)<=0&&(p.y-l.y)*(p.y-o.y)<=0&&(p.x-l.x)*(o.y-l.y)-(o.x-l.x)*(p.y-l.y)===0){f.splice(t,0,a);break}l=o}return f}static insertPoint2Border_Ring(n,s,e,a){let i,t,l,o,p,f,h,g,x,d=[],u=[],r=[];for(p=0;p<e.getLineNum();p++){for(x=e.lineList[p],u=[],l=0;l<x.pointList.length;l++)i=new J,i.id=-1,i.borderIdx=p,i.point=x.pointList[l],i.value=n[x.ijPointList[l].i][x.ijPointList[l].j],u.push(i);for(l=0;l<s.length;l++)for(t=s[l].clone(),t.borderIdx=p,g=t.point,f=u[0].point.clone(),o=1;o<u.length;o++){if(h=u[o].point.clone(),(g.x-f.x)*(g.x-h.x)<=0&&(g.y-f.y)*(g.y-h.y)<=0&&(g.x-f.x)*(h.y-f.y)-(h.x-f.x)*(g.y-f.y)===0){u.splice(o,0,t);break}f=h}for(r=[],l=0;l<u.length;l++)t=u[l],t.bInnerIdx=l,r.push(t);a[p]=r.length,d.push(...r)}return d}};let ie=A;ie._endPointList=[];function pe(n,s,e){const a=Le(s);let i=0,t=0;for(let l=0;l<4;l++){const o=n[e+l];i=i+a[l]*o.x,t=t+a[l]*o.y}return[i,t]}function de(n){return 1/6*(-n+1)*(-n+1)*(-n+1)}function ge(n){return 1/6*(3*n*n*n-6*n*n+4)}function ye(n){return 1/6*(-3*n*n*n+3*n*n+3*n+1)}function ce(n){return 1/6*n*n*n}function Le(n){return[de(n),ge(n),ye(n),ce(n)]}function Pe(n,s){let e,a,i,t,l,o=[];if(s<4)return null;let p=!1;l=n[0];let f=n[s-1];for(l.x===f.x&&l.y===f.y&&(n.splice(0,1),n.push(n[0]),n.push(n[1]),n.push(n[2]),n.push(n[3]),n.push(n[4]),n.push(n[5]),n.push(n[6]),p=!0),s=n.length,a=0;a<s-3;a++)for(e=0;e<=1;e+=.05){let h=pe(n,e,a);i=h[0],t=h[1],p?a>3&&(l=new O,l.x=i,l.y=t,o.push(l)):(l=new O,l.x=i,l.y=t,o.push(l))}return p?o.push(o[0]):(o.splice(0,0,n[0]),o.push(n[n.length-1])),o}function we(n){let s=[];for(let e=0;e<n.length;e++){const a=n[e],i=a.pointList;if(i.length<=1)continue;if(i.length===2){let l=new O,o=i[0],p=i[1];l.x=(p.x-o.x)/4+o.x,l.y=(p.y-o.y)/4+o.y,i.splice(1,0,l),l=new O,l.x=(p.x-o.x)/4*3+o.x,l.y=(p.y-o.y)/4*3+o.y,i.splice(2,0,l)}if(i.length===3){let l=new O,o=i[0],p=i[1];l.x=(p.x-o.x)/2+o.x,l.y=(p.y-o.y)/2+o.y,i.splice(1,0,l)}const t=Pe(i,i.length);a.pointList=t,s.push(a)}return s}function be(n){const s=n.pointList.map(e=>[e.x,e.y]);return{type:"Feature",geometry:{type:"LineString",coordinates:s},properties:{value:n.value}}}function Ie(n){const s=[];for(const e of n){const a=be(e);s.push(a)}return{type:"FeatureCollection",features:s}}function ve(n,s){const{outLine:e,holeLines:a}=n,t=[e.pointList.map(o=>[o.x,o.y])];let l=e.value;if(n.isHighCenter){const o=s.indexOf(n.lowValue);o>=0&&o<s.length-1?l=s[o+1]:l=n.lowValue}if(n.hasHoles())for(let o=0;o<a.length;o++){const p=a[o],f=[];for(let h=0,g=p.pointList;h<g.length;h++){const x=g[h];f.push([x.x,x.y])}t.push(f)}return{type:"Feature",geometry:{type:"Polygon",coordinates:t},properties:{value:l}}}function Me(n,s){const e=[];for(const a of n){const i=ve(a,s);e.push(i)}return{type:"FeatureCollection",features:e}}Q.Contour=ie,Q.isobands=Me,Q.isolines=Ie,Q.smoothLines=we,Object.defineProperties(Q,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
